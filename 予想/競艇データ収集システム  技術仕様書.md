# 競艇データ収集システム `boatrace-collector` 技術仕様書

## 1. 概要

本システムは、競艇公式サイトからレース関連データを自動的に収集し、指定されたPostgreSQLデータベースに保存するPythonアプリケーションです。データ収集は、Render.comのCron Job機能を利用して定期的に実行されます。

主な機能は以下の通りです：
- **日次収集**: 毎日、その日に開催されるレースの基本情報を収集します。
- **定期収集**: レースのオッズや結果を定期的に収集します（現在はレース情報収集のみ実装）。

データ収集の中核には、外部ライブラリ `pyjpboatrace` を使用しています。

## 2. システムアーキテクチャ

本システムは、以下のコンポーネントで構成されています。

- **Render Cron Jobs**: スケジューラとして機能し、指定された時刻に収集スクリプトを起動します。
- **Python Scripts**: データ収集とデータベースへの保存処理を実行するメインロジックです。
- **PostgreSQL Database**: 収集したデータを永続的に保存するデータベースです。
- **pyjpboatrace Library**: 競艇公式サイトをスクレイピングし、データを取得するための外部ライブラリです。

![Architecture Diagram](https://i.imgur.com/placeholder.png)  <!-- Placeholder for diagram -->

**処理フロー:**
1. Renderが指定時刻にCron Jobをトリガーします。
2. Cron Jobは `cron_jobs.py` スクリプトを、引数（`daily`, `odds_regular`など）付きで実行します。
3. `cron_jobs.py` は、引数に応じて `collector.py` 内の対応する関数を呼び出します。
4. `collector.py` の `BoatraceCollector` クラスが `pyjpboatrace` ライブラリを使い、公式サイトからデータを取得します。
5. 取得したデータは整形され、`psycopg2` を通じてPostgreSQLデータベースに保存されます。

## 3. ファイル構成

プロジェクトの主要なファイルは `boatrace-collector` ディレクトリに格納されています。

```
boatrace-collector/
├── README.md           # プロジェクトの概要とセットアップ手順
├── requirements.txt    # Pythonの依存ライブラリ
└── src/
    ├── collector.py    # データ収集とDB保存のコアロジック
    └── cron_jobs.py    # Cron Jobのエントリポイント
```

### `src/cron_jobs.py`
RenderのCron Jobから直接呼び出されるエントリポイントです。コマンドライン引数としてジョブ名を受け取り、`collector.py`内の対応するビジネスロジックを実行します。

- **`job_daily_collection()`**: 日次収集ジョブ。当日のレース情報を収集。
- **`job_odds_collection_regular()`**: 定期オッズ収集ジョブ。（現在、日次収集と同じ動作）
- **`job_result_collection()`**: 結果収集ジョブ。（現在、機能無効）

### `src/collector.py`
データ収集とデータベース操作の具体的な処理を実装したコアファイルです。

- **`BoatraceCollector` クラス**: データ収集のメインクラス。
  - **`get_today_races()`**: `pyjpboatrace` を使って当日のレース情報を取得・整形します。
  - **`save_races()`**: 取得したレース情報をデータベースに保存します。

## 4. 実行環境

### 4.1. デプロイ設定 (`render.yaml`)

本システムは `render.yaml` に基づいて、3つのCron JobとしてRenderにデプロイされます。

| ジョブ名 | スケジュール (JST) | コマンド | 役割 |
| :--- | :--- | :--- | :--- |
| `boatrace-daily-collection` | 毎日 08:00 | `python cron_jobs.py daily` | 当日開催される全レースの情報をDBに登録する。 |
| `boatrace-odds-regular` | 10分ごと (08:00-21:00) | `python cron_jobs.py odds_regular` | 未終了レースのオッズを収集する。（現在は日次収集と同じ） |
| `boatrace-result-collection` | 15分ごと (08:00-22:00) | `python cron_jobs.py result` | 終了したレースの結果と払戻金を収集する。（現在は無効） |

### 4.2. 依存ライブラリ (`requirements.txt`)

| ライブラリ | バージョン | 用途 |
| :--- | :--- | :--- |
| `pyjpboatrace` | `>=0.5.0` | 競艇公式サイトからのデータスクレイピング |
| `psycopg2-binary` | `>=2.9.0` | PostgreSQLデータベースへの接続 |
| `requests` | `>=2.28.0` | `pyjpboatrace` の依存ライブラリ |

### 4.3. 環境変数

| 変数名 | 説明 | 必須 |
| :--- | :--- | :--- |
| `DATABASE_URL` | 接続先のPostgreSQLデータベースURL | はい |
| `TZ` | タイムゾーン設定 (`Asia/Tokyo`) | はい |

## 5. データソース (`pyjpboatrace` ライブラリ仕様)

データ収集は `pyjpboatrace` ライブラリに全面的に依存しています。

- **プロジェクトリポジトリ**: [https://github.com/hmasdev/pyjpboatrace](https://github.com/hmasdev/pyjpboatrace)
- **バージョン**: 0.5.0

### `get_stadiums` メソッド

本システムで最も重要なメソッドです。指定された日付に開催されているレース場の一覧と、その概要を返します。

- **シグネチャ**: `get_stadiums(d: datetime.date) -> Dict[str, Any]`
- **戻り値**: キーが競艇場名（日本語）、値が開催情報（辞書）または `None` となる辞書。

**戻り値のデータ構造（重要）**

テスト実行により、このメソッドの戻り値には以下の特性があることが判明しています。これが過去のエラーの根本原因でした。

1.  戻り値の辞書には、各競艇場の情報だけでなく、**`"date"` というキーを持つ日付文字列がメタデータとして含まれます。**
2.  開催されていない競艇場の値は `None` になります。

```json
// 2026-01-04実行時のサンプル出力
{
  "桐生": null, // 非開催
  "戸田": {      // 開催中
    "status": "9R以降発売中",
    "grade": ["ippan"],
    "title": "第４４回新春金盃だるま家カップスタ展１０時１０分！",
    "day": "３日目",
    ...
  },
  ...
  "date": "2026-01-04" // 文字列型のメタデータ
}
```

`collector.py` の `get_today_races` 関数では、この仕様に対応するため、ループ処理の中で `isinstance(info, dict)` を用いて値が辞書型であるかを判定し、文字列型のメタデータをスキップする処理を行っています。

## 6. データベーススキーマ

プロジェクト内にスキーマ定義ファイル（`.sql`）は含まれていませんでしたが、`collector.py` のコードから以下のテーブル構造を推測できます。

### `races` テーブル

収集したレースの基本情報を格納します。

| カラム名 | 型 | 説明 | コードからの推測 |
| :--- | :--- | :--- | :--- |
| `id` | `INTEGER` (PK) | レースの一意なID | `save_races` の `RETURNING id` |
| `race_date` | `DATE` | レース開催日 | `save_races` のINSERT文 |
| `stadium_code` | `INTEGER` | 競艇場コード (1-24) | `save_races` のINSERT文 |
| `race_number` | `INTEGER` | レース番号 (1-12) | `save_races` のINSERT文 |
| `title` | `VARCHAR` | レースのタイトル | `save_races` のINSERT文 |
| `deadline_at` | `TIMESTAMP` | 締切時刻 | `save_races` のINSERT文 |

**複合ユニークキー**: (`race_date`, `stadium_code`, `race_number`) に設定されていると推測されます。

### `stadiums` テーブル

`cron_jobs.py` のテスト用関数 `job_test` 内に `SELECT COUNT(*) FROM stadiums` というクエリがあることから、競艇場マスタテーブルの存在が示唆されます。構造は不明ですが、少なくとも以下のカラムを持つと推測されます。

| カラム名 | 型 | 説明 |
| :--- | :--- | :--- |
| `code` | `INTEGER` (PK) | 競艇場コード |
| `name` | `VARCHAR` | 競艇場名 |

## 7. エラー履歴と根本原因

開発過程で複数の `IndentationError` や `AttributeError: 'str' object has no attribute 'get'` が発生しました。これらのエラーの根本原因は、セクション5で詳述した `pyjpboatrace.get_stadiums` メソッドの戻り値の仕様を開発者（AI）が誤解していたことにあります。戻り値に含まれる文字列型のメタデータを考慮せずに処理しようとした結果、エラーが発生していました。

現在のコードは、この仕様を正しく理解し、対処するロジックが実装されています。


## 8. ソースコード全文

他のAIによる検証を容易にするため、現在デプロイされているソースコードの全文を以下に掲載します。

### 8.1. `src/collector.py`

```python
'''
競艇データ収集システム - メインコレクター
pyjpboatraceライブラリを使用して公式サイトからデータを取得します。
'''

import os
import logging
from datetime import datetime, timedelta, timezone
from typing import Optional, List, Dict, Any
import json

import psycopg2
from psycopg2.extras import execute_values, Json
from pyjpboatrace import PyJPBoatrace

# ロギング設定
logging.basicConfig(
    level=logging.INFO, format="%(asctime)s - %(levelname)s - %(message)s"
)
logger = logging.getLogger(__name__)

# 日本時間
JST = timezone(timedelta(hours=9))

# 競艇場名とコードのマッピング
STADIUM_MAP = {
    '桐生': 1, '戸田': 2, '江戸川': 3, '平和島': 4, '多摩川': 5, '浜名湖': 6,
    '蒲郡': 7, '常滑': 8, '津': 9, '三国': 10, 'びわこ': 11, '住之江': 12,
    '尼崎': 13, '鳴門': 14, '丸亀': 15, '児島': 16, '宮島': 17, '徳山': 18,
    '下関': 19, '若松': 20, '芦屋': 21, '福岡': 22, '唐津': 23, '大村': 24
}

class BoatraceCollector:
    "競艇データ収集クラス"

    def __init__(self, database_url: str):
        self.database_url = database_url
        self.boatrace = PyJPBoatrace()
        self.conn = None

    def connect_db(self):
        "データベースに接続"
        if self.conn is None or self.conn.closed:
            self.conn = psycopg2.connect(self.database_url)
            logger.info("データベースに接続しました")

    def close_db(self):
        "データベース接続を閉じる"
        if self.conn and not self.conn.closed:
            self.conn.close()
            logger.info("データベース接続を閉じました")

    def get_today_races(self, target_date: datetime) -> List[Dict[str, Any]]:
        "指定日の全レース情報を取得"
        races = []
        try:
            stadiums_info = self.boatrace.get_stadiums(d=target_date.date())
            if not stadiums_info:
                logger.info("開催中のレース情報はありませんでした。")
                return []

            for stadium_name, info in stadiums_info.items():
                # infoが辞書型でない場合（例: 'date'キー）、スキップ
                if not isinstance(info, dict):
                    continue

                # is_openフラグがない場合や、statusが発売中でない場合はスキップ
                # 「最終R発売終了」のようなステータスも除外
                status = info.get("status", "")
                if "発売中" not in status:
                    continue

                stadium_code = STADIUM_MAP.get(stadium_name)
                if not stadium_code:
                    logger.warning(f"不明な競艇場名です: {stadium_name}")
                    continue

                # この場は開催中、各レースの情報を取得
                for race_num in range(1, 13):
                    races.append({
                        "race_date": target_date.date(),
                        "stadium_code": stadium_code,
                        "race_number": race_num,
                        "title": info.get("title", ""),
                        "deadline_at": None, # オッズ取得時に更新
                    })

        except Exception as e:
            logger.error(f"レース情報取得中にエラーが発生しました: {e}", exc_info=True)

        logger.info(f"{target_date.date()} のレース数: {len(races)}")
        return races

    def save_races(self, races: List[Dict[str, Any]]) -> Dict[tuple, int]:
        "レース情報をDBに保存し、race_idのマッピングを返す"
        self.connect_db()
        race_id_map = {}
        with self.conn.cursor() as cur:
            # 既存のレースIDを先に取得
            existing_races = {}
            race_keys = [(r['race_date'], r['stadium_code'], r['race_number']) for r in races]
            if not race_keys:
                logger.info("保存対象のレースはありませんでした。")
                return {}

            cur.execute(
                "SELECT id, race_date, stadium_code, race_number FROM races WHERE (race_date, stadium_code, race_number) IN %s",
                (tuple(race_keys),)
            )
            for row in cur.fetchall():
                key = (row[1], row[2], row[3])
                existing_races[key] = row[0]

            # 新規レースと更新レースを分ける
            new_races_to_insert = []
            for race in races:
                key = (race['race_date'], race['stadium_code'], race['race_number'])
                if key in existing_races:
                    race_id_map[key] = existing_races[key]
                else:
                    new_races_to_insert.append(race)

            # 新規レースを一括登録
            if new_races_to_insert:
                insert_query = (
                    "INSERT INTO races (race_date, stadium_code, race_number, title, deadline_at) "
                    "VALUES %s RETURNING id, race_date, stadium_code, race_number"
                )
                values = [
                    (
                        r['race_date'], r['stadium_code'], r['race_number'],
                        r['title'], r['deadline_at']
                    ) for r in new_races_to_insert
                ]
                try:
                    inserted_rows = execute_values(cur, insert_query, values, fetch=True)
                    self.conn.commit()
                    for row in inserted_rows:
                        key = (row[1], row[2], row[3])
                        race_id_map[key] = row[0]
                    logger.info(f"{len(inserted_rows)} 件の新規レースを保存しました")
                except Exception as e:
                    logger.error(f"新規レースの保存中にエラーが発生しました: {e}")
                    self.conn.rollback()
            else:
                logger.info("新規レースはありませんでした。")

        return race_id_map

# --- オッズ・結果収集機能は、まずレース情報取得の正常化を確認してから再実装 ---

def run_daily_collection(database_url: str):
    "日次収集を実行"
    collector = BoatraceCollector(database_url)
    today = datetime.now(JST)
    races = collector.get_today_races(today)
    if races:
        collector.save_races(races)
    collector.close_db()

def run_odds_regular_collection(database_url: str):
    "定期オッズ収集を実行"
    logger.info("オッズ収集(regular)は現在、日次収集と同じ動作をします。")
    run_daily_collection(database_url)

def run_result_collection(database_url: str):
    "結果収集を実行"
    logger.info("結果収集機能は現在無効化されています。")
```

### 8.2. `src/cron_jobs.py`

```python
"""
競艇データ収集システム - Cron Job エントリポイント
Renderのスケジュールジョブから呼び出されるスクリプトです。
"""

import os
import sys
import logging
from datetime import datetime, timedelta, timezone

# ロギング設定
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger(__name__)

# 日本時間
JST = timezone(timedelta(hours=9))


def get_database_url():
    """データベースURLを取得"""
    url = os.environ.get('DATABASE_URL')
    if not url:
        logger.error("DATABASE_URL環境変数が設定されていません")
        sys.exit(1)
    return url


def job_daily_collection():
    """
    日次収集ジョブ
    毎朝8:00 JSTに実行。当日の全レース情報と初期オッズを収集。
    """
    from collector import run_daily_collection
    
    logger.info("=== 日次収集ジョブ開始 ===")
    database_url = get_database_url()
    
    try:
        run_daily_collection(database_url)
        logger.info("=== 日次収集ジョブ完了 ===")
    except Exception as e:
        logger.error(f"日次収集ジョブ失敗: {e}")
        sys.exit(1)


def job_odds_collection_regular():
    """
    定期オッズ収集ジョブ
    10分ごとに実行。未終了レースのオッズを収集。
    """
    from collector import run_odds_regular_collection
    
    logger.info("=== 定期オッズ収集ジョブ開始 ===")
    database_url = get_database_url()
    
    try:
        run_odds_regular_collection(database_url)
        logger.info("=== 定期オッズ収集ジョブ完了 ===")
    except Exception as e:
        logger.error(f"定期オッズ収集ジョブ失敗: {e}")
        sys.exit(1)


def job_odds_collection_high_freq():
    """
    高頻度オッズ収集ジョブ
    1分ごとに実行。締切5分前のレースのオッズを収集。
    """
    from collector import run_odds_regular_collection
    
    logger.info("=== 高頻度オッズ収集ジョブ開始 ===")
    database_url = get_database_url()
    
    try:
        # High frequency collection is not implemented yet.
        pass
        logger.info("=== 高頻度オッズ収集ジョブ完了 ===")
    except Exception as e:
        logger.error(f"高頻度オッズ収集ジョブ失敗: {e}")
        sys.exit(1)


def job_result_collection():
    """
    結果収集ジョブ
    15分ごとに実行。終了したレースの結果と払戻金を収集。
    """
    from collector import run_result_collection
    
    logger.info("=== 結果収集ジョブ開始 ===")
    database_url = get_database_url()
    
    try:
        run_result_collection(database_url)
        logger.info("=== 結果収集ジョブ完了 ===")
    except Exception as e:
        logger.error(f"結果収集ジョブ失敗: {e}")
        sys.exit(1)


def job_test():
    """
    テストジョブ
    デプロイ確認用。DB接続をテストして終了。
    """
    import psycopg2
    
    logger.info("=== テストジョブ開始 ===")
    database_url = get_database_url()
    
    try:
        conn = psycopg2.connect(database_url)
        with conn.cursor() as cur:
            cur.execute("SELECT COUNT(*) FROM stadiums")
            count = cur.fetchone()[0]
            logger.info(f"stadiumsテーブルのレコード数: {count}")
            
            cur.execute("SELECT NOW()")
            db_time = cur.fetchone()[0]
            logger.info(f"データベース時刻: {db_time}")
            
        conn.close()
        logger.info("=== テストジョブ完了: DB接続成功 ===")
    except Exception as e:
        logger.error(f"テストジョブ失敗: {e}")
        sys.exit(1)


if __name__ == '__main__':
    if len(sys.argv) < 2:
        print("Usage: python cron_jobs.py <job_name>")
        print("Available jobs: daily, odds_regular, odds_high_freq, result, test")
        sys.exit(1)
        
    job_name = sys.argv[1]
    
    jobs = {
        'daily': job_daily_collection,
        'odds_regular': job_odds_collection_regular,
        'odds_high_freq': job_odds_collection_high_freq,
        'result': job_result_collection,
        'test': job_test,
    }
    
    if job_name not in jobs:
        logger.error(f"不明なジョブ名: {job_name}")
        print(f"Available jobs: {', '.join(jobs.keys())}")
        sys.exit(1)
        
    jobs[job_name]()
```

### 8.3. `render.yaml` (デプロイ設定)

```yaml
services:
  # Web Service for frontend, API, and batch processing (既存)
  - type: web
    name: ai-auto-mailer
    env: node
    region: singapore
    plan: free
    buildCommand: pip install -r requirements.txt && pnpm install && pnpm build
    startCommand: pnpm start
    envVars:
      - key: NODE_ENV
        value: production
      - key: DATABASE_URL
        sync: false
      - key: GEMINI_API_KEY
        sync: false
      - key: CHATWORK_API_TOKEN
        sync: false
      - key: SMTP_HOST
        sync: false
      - key: SMTP_PORT
        sync: false
      - key: SMTP_USER
        sync: false
      - key: SMTP_PASSWORD
        sync: false
      - key: SMTP_FROM
        sync: false

  # 競艇データ収集: 日次収集ジョブ（毎朝8:00 JST = 23:00 UTC前日）
  - type: cron
    name: boatrace-daily-collection
    runtime: python
    region: singapore
    buildCommand: pip install -r boatrace-collector/requirements.txt
    startCommand: cd boatrace-collector/src && python cron_jobs.py daily
    schedule: "0 23 * * *"
    envVars:
      - key: DATABASE_URL
        sync: false
      - key: TZ
        value: Asia/Tokyo

  # 競艇データ収集: 定期オッズ収集ジョブ（10分ごと、8:00-21:00 JST）
  - type: cron
    name: boatrace-odds-regular
    runtime: python
    region: singapore
    buildCommand: pip install -r boatrace-collector/requirements.txt
    startCommand: cd boatrace-collector/src && python cron_jobs.py odds_regular
    schedule: "*/10 23,0-12 * * *"
    envVars:
      - key: DATABASE_URL
        sync: false
      - key: TZ
        value: Asia/Tokyo

  # 競艇データ収集: 結果収集ジョブ（15分ごと）
  - type: cron
    name: boatrace-result-collection
    runtime: python
    region: singapore
    buildCommand: pip install -r boatrace-collector/requirements.txt
    startCommand: cd boatrace-collector/src && python cron_jobs.py result
    schedule: "*/15 23,0-13 * * *"
    envVars:
      - key: DATABASE_URL
        sync: false
      - key: TZ
        value: Asia/Tokyo
```

### 8.4. `requirements.txt`

```
pyjpboatrace>=0.5.0
psycopg2-binary>=2.9.0
requests>=2.28.0
```

## 9. 検証手順

他のAIがこのシステムを検証する際の推奨手順を以下に示します。

1.  **ライブラリの出力確認**: `pyjpboatrace` ライブラリをインストールし、`get_stadiums` メソッドの出力を直接確認してください。
    ```python
    import datetime
    from pyjpboatrace import PyJPBoatrace
    import json

    boatrace = PyJPBoatrace()
    today = datetime.date.today()
    stadiums_info = boatrace.get_stadiums(d=today)
    print(json.dumps(stadiums_info, indent=2, ensure_ascii=False))
    ```
    出力に `"date"` キーが含まれていること、および開催していない場の値が `null` であることを確認してください。

2.  **コードレビュー**: `collector.py` の `get_today_races` メソッド内のループ処理で、`isinstance(info, dict)` による型チェックが行われていることを確認してください。これが、文字列型のメタデータをスキップするための重要なロジックです。

3.  **データベーススキーマの確認**: `races` テーブルが存在し、`race_date`, `stadium_code`, `race_number`, `title`, `deadline_at` カラムを持っていることを確認してください。

## 10. 今後の課題

現在のシステムは、レース情報の収集のみが実装されています。以下の機能は未実装または無効化されています。

- **オッズ収集**: `run_odds_regular_collection` は現在、日次収集と同じ動作をしています。本来はオッズデータを収集・保存する機能を実装する必要があります。
- **結果収集**: `run_result_collection` は現在、何も処理を行いません。レース結果と払戻金を収集・保存する機能を実装する必要があります。
- **高頻度オッズ収集**: `job_odds_collection_high_freq` は未実装です。

---

**作成日**: 2026年1月4日
**作成者**: Manus AI
